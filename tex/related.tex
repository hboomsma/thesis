\chapter{Related work\label{ch:related}}

A lot of research has been conducted in the field of software optimization, making programs quicker, more memory efficient and smaller. Removing code can serve the purpose of a quick and small application with a memory footprint as small as possible but also the purpose of making the program easier to maintain and less prone to bugs which is the same purpose as in this thesis.

Srivastava\cite{srivastava1992} describes how the use of Object-Oriented programming can introduce unreachable procedures and describes a way to detect and remove them in C and C++ by building a static call graph. This method can not handle virtual functions. This problem is later addressed by Bacon\cite{bacon1996} whith research on fast static analysis of virtual functions calls in C++. Removing functions in such a context is even more important in newer languages which often declare functions virtual by default. Strivastava sees dead code elimination just as a way to enhance the performance of the application whereas Bacon sees it as a way to reduce the size and complexity of the application to improve human and automated analysis. Improving human analysis and comprehension is the goal in this thesis too, together with maintainability. Srivastava and Bacon focus on static analysis for compiled languages and detecting unreachable code whereas in this thesis is focused on the identification of unused code to improve maintainability which is only possible with dynamic analysis.

Debray\cite{debray2000} describes techniques for compilers to reduce executable size including redundant code elimination and unreachable code elimination.  Over time many refinements and techniques for specific situations have been proposed. Liu\cite{liu1999} describes eliminating dead code in the presence of recursive data. Sunitha\cite{sunitha2006} uses value numbering to improve the dead code identification. 

%revise sentence
Biggar and de Vries\cite{biggar2009draft,biggar2009,biggar2010,devries2007} created a method for static analysis for PHP with the purpose of creating a compiler with an dead code elimination step. This dead code elimination only removes dead code from the compiled program and does not offer dead function removal. In this research is mainly focused on gathering enough information to be able to compile PHP in to C. There still is a dependency on PHP to solve some of the dynamic behaviour. When deciding to use dynamic or static analysis this this work was used to see if it where possible to get a call graph from the code that could be used to find dead methods and classes. Because static analysis is used opposed to the dynamic analysis used in this thesis with this method only unreachable code can be eliminated. Because of the dynamic behaviour of PHP, even eliminating unreachable code found with static analysis, can not be automated safely.

%compare to own work
The tool \furl{phpcallgraph} could be used for unreachable function detection, but the program does no type inference and only supports situations where the type hinting of PHP applies, it does not take annotations into account. The program showed not very robust when building a call graph for any of the applications from the use cases. WebSSARI\cite{huang2004}, Web vulnerabilities\cite{xie2006} and Pixy\cite{jovanovic2006} miss also support or do not model PHP close enough to give to  give data that could be used for dead code elimination in a reliable way\cite{biggar2009}. These tools can be used to get methods invocations and type information to build a call graph which enables dead code identification but because they all do not very well model PHP the type information will often not be available making it impossible to build a proper call graph. By using dynamic analysis in this thesis we do not have to problem of missing information.

Two other projects that could be used for coverage analysis of a running program over a longer time could be \furl{xdebug} and \furl{zendserver}. Because here dynamic analysis is used these projects could used to gather data about alive files or methods and feed it into the visualizations created for this thesis. XDebug and Zend Server will be able to detect unused code as is the case in this thesis. Both record traces of the PHP application at runtime at the expense of longer running times and huge amounts of data. XDebug can not be used because the big overhead and Zend Server not because the amount of data is too big (see chapter \ref{ch:identification}). 

When using virtual machines, optimization is possible in the \jit compiler. \Gls{jit} compilers could also benefit from the runtime type information in detecting dead code. Efficient \jit execution of dynamically typed languages is discussed by Chang\cite{chang2007}, this work could be used to identify dead code using runtime trace and runtime type information from the virtual machine. This is would be a dynamic extension of a static analysis to determine unreachable code, instead of a real dynamic analysis that is capable of detecting unused code too.

Lucca\cite{lucca2005} proposes the use of both static and dynamic analysis to get a better understanding of an application. The combining of data from multiple ways of analysis is something also done for this thesis. Not only the dynamic data but also the \vcs data is used. In the future also basic static analysis data could be added.


%make easier to follor, partially dead code
Knoop\cite{knoop1994} and Briggs\cite{briggs1994} describe how partial dead code can affect the performance of an application and how it can be removed. Their method relies on static analysis. Removing partial dead code is done to make the executable small and faster. Whereas this is also dead code elimination it doest not have the intention of improving human comprehension of the application or to ease maintenance.
 

%abstract, very formal, compare with own work, a high level of what
Beyer\cite{beyer2004} describes a way to uncover dead code via formal model checking and implemented their method as \furl{eclipse} plug-in. This is on a far more abstract level than the work described in this thesis, but formal methods are equally valid for applications written in dynamic or static languages, however they do not uncover unused features. A lot of effort has to be put in to formally proving the correctness of an application, something not seen often in the fast moving web application business.

Janota\cite{janota2007} does not only consider the code in the reachability analysis but also takes annotations into account which pose extra limitations on the values of parameters. This way redundant and unreachable code can be detected that otherwise would have been considered reachable but in practice will be never executed because the variables will never hold the required values to enter a specific branch.

Besides dead code elimination methods for low level code and source in procedural/imperative languages also dead code identification and elimination in functional languages has been researched. Gen\`eves\cite{geneves2010} looked into eliminating dead code from XQuery Programs. Damiani describes dead code elimination in functional languages using type inference\cite{damiani2000} and rank 2 intersection\cite{damiani1997}. Xi\cite{xi1998} also uses type information to detect and eliminate dead code. 


Dynamically removing dead code is possible in hardware too. Butts\cite{butts2002} describes a way using flow detection to predict if an instruction will be dead, this information is used for the scheduling of the instructions within the processor.

Most of the dead code elimination techniques are used to optimize the application, where this thesis eliminates code to make the source code more maintainable and easier to test\cite{huang2003}. Maintainability often conflicts with optimizations as described by\cite{andreopoulos2004,kiewkanya2005}.