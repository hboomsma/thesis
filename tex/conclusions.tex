\chapter{Summary, conclusions and future work\label{ch:conclusions}\label{ch:future}}


Software undergoes evolution which inevitably leads to software ageing and disuse of software pieces which leads to higher maintenance cost and less performance\cite{chen1998,godfrey2000,huang2003,kiewkanya2005,scanniello2011}. Elimination of dead code takes a big effort\cite{andreopoulos2004,jones2006,scanniello2011}. We look into dead code elimination for web application written in dynamic languages. We discuss where, when and how to measure which code is dead, what the overhead is and what granularity is needed for the dead code identification (e.g. files, classes or functions).

In this thesis, we developed and evaluated methods and tools for supporting engineers in the detection and removal of dead code. We used a dynamic analysis because we deal with a dynamic language for which static analysis is very cumbersome\cite{biggar2009,biggar2009draft,biggar2010,devries2007,tratt2009} and this way we are able to detect unused but working features. We measure which files are used and translate this in a set of potentially dead files. The measurement is done by using native language features of PHP to get a list of all files used and execute code after every execution of PHP to send the usage data to a central database. Two visualizations are build, one integrated in Eclipse the other is a website containing a tree map to easily indicate where the most potentially dead code can be found. From a case study we know that how long we have to wait after the dead code identification phase to start with the dead code elimination is dependent on the size, usage and type of application. The case study also shows that the visualizations are found helpful by the developers, and that the Eclipse plug-in prevents time being wasted on dead files while debugging or developing new features.

The identification, visualizations and dead code elimination procedure are thus far only used and tested within Hostnet. Future research should be conducted to find out how well the work done in this thesis is usable in other companies and projects. As enhancement for the current analysis. In the current tools shared code between applications has to be taken into account manually, in the future an automated way of detection shared code between multiple could be build based on \vcs data. For the dead code identification a statistical model should be build to indicate with which amount of certainty a file can be considered dead. During the identification phase sometimes new files are accessed after a while. A notification system could be made to make the developers aware of the fact new files are accessed. I would like to research the possibility of dead method identification. With a lower granularity it is possible to remove more dead code and dead methods create a unnecessary complex view when looking at an application which will prolong development time and could lead to bugs when the dead method is resurrected. The main concern when performing dynamic analysis with a granularity of a method is the overhead caused.